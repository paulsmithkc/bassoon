{"version":3,"sources":["webpack://bassoon/webpack/bootstrap","webpack://bassoon/webpack/runtime/define property getters","webpack://bassoon/webpack/runtime/hasOwnProperty shorthand","webpack://bassoon/./src/bassoon.mjs","webpack://bassoon/./src/Emitter.mjs","webpack://bassoon/./src/Parser.mjs"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","bassoon","arg1","abort","aborted","xhr","onreadystatechange","onload","onerror","emitData","data","chunkSize","chunk","push","length","emitter","emit","args","url","_events","_get","this","callback","queue","on","event","i","worker","Worker","URL","location","toString","workerPath","workerObj","onmessage","evt","cmd","postMessage","method","withCredentials","verbose","parser","depth","stack","parseKey","pattern","keyPattern","lastIndex","match","exec","buffer","groups","value1","value2","state","VALUE","parseValue","type","STRING","stringPattern","NUMBER","numberPattern","TRUE","truePattern","FALSE","falsePattern","NULL","nullPattern","UNDEFINED","undefinedPattern","value","parseFloat","undefined","BEGIN","pop","parse","c","END","ARRAY","OBJECT","KEY","Error","substring","end","Parser","console","log","repeat","curObj","curKey","seen","XMLHttpRequest","open","responseType","readyState","fullText","responseText","newText","substr","error","status","statusText","timeout","send"],"mappings":"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","file":"bassoon.min.js","sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","import Emitter from './Emitter.mjs';\r\nimport Parser from './Parser.mjs';\r\n\r\nexport default function bassoon(arg1) {\r\n  'use strict';\r\n\r\n  const args = typeof arg1 === 'string' ? { url: arg1 } : arg1;\r\n\r\n  // web worker integration\r\n  const emitter = Emitter();\r\n  let aborted = false;\r\n  if (args.worker && Worker) {\r\n    // fix the URL so that it is relative to the current page\r\n    args.url = new URL(args.url, location).toString();\r\n    // start the worker\r\n    const workerPath = args.workerPath || '/bassoon/bassoon-worker.min.js';\r\n    const workerObj = new Worker(workerPath);\r\n    workerObj.onmessage = function (evt) {\r\n      if (!aborted) emitter.emit(evt.data.cmd, evt.data.data);\r\n    };\r\n    workerObj.postMessage({ cmd: 'start', args });\r\n    emitter.abort = function () {\r\n      aborted = true;\r\n      workerObj.postMessage({ cmd: 'abort' });\r\n    };\r\n    return emitter;\r\n  }\r\n\r\n  // arguments\r\n  const url = args.url;\r\n  const method = args.method || 'GET';\r\n  const withCredentials = args.withCredentials || false;\r\n  const verbose = args.verbose || false;\r\n  const chunkSize = args.chunkSize;\r\n\r\n  // request state\r\n  const parser = Parser(parse);\r\n  let xhr = null;\r\n  let seen = 0;\r\n  let chunk = [];\r\n  let stack = [];\r\n  let curObj = null;\r\n  let curKey = null;\r\n\r\n  // methods\r\n\r\n  function abort() {\r\n    aborted = true;\r\n    if (xhr) {\r\n      xhr.onreadystatechange = null;\r\n      xhr.onload = null;\r\n      xhr.onerror = null;\r\n      xhr.abort();\r\n    }\r\n  }\r\n\r\n  function emitData(data) {\r\n    if (aborted) return;\r\n    if (chunkSize) {\r\n      chunk.push(data);\r\n      if (chunk.length >= chunkSize) {\r\n        emitter.emit('data', chunk);\r\n        chunk = [];\r\n      }\r\n    } else {\r\n      emitter.emit('data', data);\r\n    }\r\n  }\r\n\r\n  function parse({ key, data, depth }) {\r\n    if (aborted) return;\r\n    if (verbose) console.log(' '.repeat(depth * 2), key, data);\r\n    if (curObj) {\r\n      // processing object/array\r\n      switch (key) {\r\n        case 'openarray':\r\n          stack.push({ curObj, curKey });\r\n          curObj = [];\r\n          curKey = null;\r\n          break;\r\n        case 'openobject':\r\n          stack.push({ curObj, curKey });\r\n          curObj = {};\r\n          curKey = null;\r\n          break;\r\n        case 'closearray':\r\n        case 'closeobject':\r\n          if (stack.length) {\r\n            let data = curObj;\r\n            ({ curObj, curKey } = stack.pop());\r\n            if (curKey !== null) {\r\n              curObj[curKey] = data;\r\n              curKey = null;\r\n            } else {\r\n              curObj.push(data);\r\n            }\r\n          } else {\r\n            emitData(curObj);\r\n            curObj = curKey = null;\r\n          }\r\n          break;\r\n        case 'key':\r\n          curKey = data;\r\n          break;\r\n        case 'value':\r\n          if (curKey !== null) {\r\n            curObj[curKey] = data;\r\n            curKey = null;\r\n          } else {\r\n            curObj.push(data);\r\n          }\r\n          break;\r\n      }\r\n    } else {\r\n      // processing root\r\n      switch (key) {\r\n        case 'openarray':\r\n        case 'closearray':\r\n          // ignore root array\r\n          break;\r\n        case 'openobject':\r\n          curObj = {};\r\n          break;\r\n        case 'value':\r\n          emitData(data);\r\n          break;\r\n      }\r\n    }\r\n  }\r\n\r\n  // main logic\r\n\r\n  try {\r\n    xhr = new XMLHttpRequest();\r\n    xhr.open(method || 'GET', url);\r\n    xhr.responseType = 'text';\r\n    xhr.withCredentials = withCredentials;\r\n\r\n    xhr.onreadystatechange = function (evt) {\r\n      try {\r\n        if (xhr.readyState > 2) {\r\n          const fullText = xhr.responseText;\r\n          const newText = fullText.substr(seen);\r\n          seen = fullText.length;\r\n          parser.parse(newText);\r\n        }\r\n      } catch (error) {\r\n        abort();\r\n        emitter.emit('error', error);\r\n      }\r\n    };\r\n    xhr.onload = function (event) {\r\n      try {\r\n        // let the parser terminate any partial values\r\n        parser.end();\r\n        // emit the last object, even if it is incomplete\r\n        if (stack.length) {\r\n          emitData(stack[0]);\r\n        } else if (curObj) {\r\n          emitData(curObj);\r\n        }\r\n        // emit the last chunk\r\n        if (chunk.length) {\r\n          emitter.emit('data', chunk);\r\n        }\r\n        emitter.emit('end', {\r\n          status: xhr.status,\r\n          statusText: xhr.statusText,\r\n        });\r\n      } catch (error) {\r\n        emitter.emit('error', error);\r\n      }\r\n    };\r\n    xhr.onerror = function (event) {\r\n      const error = new Error('Network Error');\r\n      error.status = xhr.status;\r\n      error.statusText = xhr.statusText;\r\n      error.timeout = xhr.timeout;\r\n      emitter.emit('error', error);\r\n    };\r\n\r\n    xhr.send();\r\n  } catch (error) {\r\n    console.error(error);\r\n    abort();\r\n    emitter.emit('error', error);\r\n  }\r\n\r\n  emitter.abort = abort;\r\n  return emitter;\r\n}\r\n","export default function Emitter() {\r\n  return {\r\n    _events: {},\r\n    _get(key) {\r\n      if (!this._events[key]) {\r\n        this._events[key] = { callback: null, queue: [] };\r\n      }\r\n      return this._events[key];\r\n    },\r\n    on(key, callback) {\r\n      const event = this._get(key);\r\n      const queue = event.queue;\r\n      event.callback = callback;\r\n      if (callback && queue.length) {\r\n        // emit missed events\r\n        for (let i = 0; i < queue.length; ++i) {\r\n          callback.call(this, queue[i]);\r\n        }\r\n        event.queue = [];\r\n      }\r\n      return this;\r\n    },\r\n    emit(key, data) {\r\n      const event = this._get(key);\r\n      const callback = event.callback;\r\n      if (callback) {\r\n        // emit current event\r\n        callback.call(this, data);\r\n      } else {\r\n        // save events so that they don't get dropped\r\n        event.queue.push(data);\r\n      }\r\n      return this;\r\n    },\r\n  };\r\n}\r\n","export default function Parser(callback) {\r\n  // states\r\n  const BEGIN = 0;\r\n  const ARRAY = 1;\r\n  const OBJECT = 2;\r\n  const KEY = 3;\r\n  const VALUE = 4;\r\n  const STRING = 5;\r\n  const NUMBER = 6;\r\n  const TRUE = 7;\r\n  const FALSE = 8;\r\n  const NULL = 9;\r\n  const UNDEFINED = 10;\r\n  const END = 11;\r\n\r\n  // patterns\r\n  // const whitespacePattern = /^[ \\t\\n\\r]+/;\r\n  const keyPattern = /((\"(?<value1>[^\\\\\"]+)\")|(?<value2>\\w+))[ \\t\\n\\r]*:[ \\t\\n\\r]*/y;\r\n  const stringPattern = /\"(?<value>(?:[^\\\\\"]|(?:\\\\[\"\\\\/bfnrtv])|(?:\\\\u[0-9a-fA-F]{4}))*)\"[ \\t\\n\\r,}\\]]/y;\r\n  const numberPattern = /(?<value>[-+]?\\d+(.\\d+)?([eE][-+]?\\d+)?)[ \\t\\n\\r,}\\]]/y;\r\n  const truePattern = /(?<value>true)[ \\t\\n\\r,}\\]]/iy;\r\n  const falsePattern = /(?<value>false)[ \\t\\n\\r,}\\]]/iy;\r\n  const nullPattern = /(?<value>null)[ \\t\\n\\r,}\\]]/iy;\r\n  const undefinedPattern = /[^ \\t\\n\\r,}\\]]+[ \\t\\n\\r,}\\]]/y;\r\n\r\n  // parser state\r\n  const stack = [];\r\n  let state = BEGIN;\r\n  let key = null;\r\n  let value = null;\r\n  let match = null;\r\n  let buffer = '';\r\n  let i = 0;\r\n\r\n  // build and return parser object\r\n  const parser = { parse, end, callback };\r\n  return parser;\r\n\r\n  function emit(key, data) {\r\n    // console.log(' '.repeat(stack.length * 2), key, data);\r\n    callback = parser.callback;\r\n    if (callback) {\r\n      callback({ key, data, depth: stack.length });\r\n    }\r\n  }\r\n\r\n  function parseKey() {\r\n    let pattern = keyPattern;\r\n    pattern.lastIndex = i;\r\n    match = pattern.exec(buffer);\r\n    if (match) {\r\n      i = pattern.lastIndex - 1;\r\n      key = match.groups.value1 || match.groups.value2;\r\n      emit('key', key);\r\n      state = VALUE;\r\n      return true;\r\n    } else {\r\n      // console.log('key incomplete', buffer.substr(i, 20), '...');\r\n      return false;\r\n    }\r\n  }\r\n\r\n  function parseValue(type) {\r\n    let pattern = null;\r\n    switch (type) {\r\n      case STRING:\r\n        pattern = stringPattern;\r\n        break;\r\n      case NUMBER:\r\n        pattern = numberPattern;\r\n        break;\r\n      case TRUE:\r\n        pattern = truePattern;\r\n        break;\r\n      case FALSE:\r\n        pattern = falsePattern;\r\n        break;\r\n      case NULL:\r\n        pattern = nullPattern;\r\n        break;\r\n      case UNDEFINED:\r\n        pattern = undefinedPattern;\r\n        break;\r\n    }\r\n\r\n    pattern.lastIndex = i;\r\n    match = pattern.exec(buffer);\r\n    if (match) {\r\n      // exclude the terminating ,}]\r\n      i = pattern.lastIndex - 2;\r\n\r\n      switch (type) {\r\n        case STRING:\r\n          value = match.groups.value;\r\n          break;\r\n        case NUMBER:\r\n          value = parseFloat(match.groups.value);\r\n          break;\r\n        case TRUE:\r\n          value = true;\r\n          break;\r\n        case FALSE:\r\n          value = false;\r\n          break;\r\n        case NULL:\r\n          value = null;\r\n          break;\r\n        case UNDEFINED:\r\n          value = undefined;\r\n          break;\r\n      }\r\n\r\n      emit('value', value);\r\n      if (state !== BEGIN) {\r\n        state = stack.pop();\r\n      }\r\n      return true;\r\n    } else {\r\n      // console.log('value incomplete', buffer.substr(i, 20), '...');\r\n      return false;\r\n    }\r\n  }\r\n\r\n  function parse(chunk) {\r\n    buffer += chunk;\r\n\r\n    for (; i < buffer.length; ++i) {\r\n      const c = buffer[i];\r\n      switch (state) {\r\n        case END:\r\n          // skip all remaining text\r\n          i = buffer.length;\r\n          break;\r\n        case BEGIN:\r\n        case VALUE:\r\n          switch (c) {\r\n            case ' ':\r\n            case '\\t':\r\n            case '\\n':\r\n            case '\\r':\r\n              // ignore whitespace\r\n              break;\r\n            case '[':\r\n              emit('openarray');\r\n              state = ARRAY;\r\n              break;\r\n            case '{':\r\n              emit('openobject');\r\n              state = OBJECT;\r\n              break;\r\n            case '\"':\r\n              if (!parseValue(STRING)) {\r\n                // continue parsing when we get more data\r\n                return;\r\n              }\r\n              break;\r\n            case '-':\r\n            case '+':\r\n            case '.':\r\n            case '0':\r\n            case '1':\r\n            case '2':\r\n            case '3':\r\n            case '4':\r\n            case '5':\r\n            case '6':\r\n            case '7':\r\n            case '8':\r\n            case '9':\r\n              if (!parseValue(NUMBER)) {\r\n                // continue parsing when we get more data\r\n                return;\r\n              }\r\n              break;\r\n            case 't':\r\n            case 'T':\r\n              if (!parseValue(TRUE)) {\r\n                // continue parsing when we get more data\r\n                return;\r\n              }\r\n              break;\r\n            case 'f':\r\n            case 'F':\r\n              if (!parseValue(FALSE)) {\r\n                // continue parsing when we get more data\r\n                return;\r\n              }\r\n              break;\r\n            case 'n':\r\n            case 'N':\r\n              if (!parseValue(NULL)) {\r\n                // continue parsing when we get more data\r\n                return;\r\n              }\r\n              break;\r\n            default:\r\n              if (!parseValue(UNDEFINED)) {\r\n                // continue parsing when we get more data\r\n                return;\r\n              }\r\n              break;\r\n          }\r\n          break;\r\n        case ARRAY:\r\n          switch (c) {\r\n            case ' ':\r\n            case '\\t':\r\n            case '\\n':\r\n            case '\\r':\r\n              // ignore whitespace\r\n              break;\r\n            case ']':\r\n              emit('closearray');\r\n              state = stack.length ? stack.pop() : BEGIN;\r\n              break;\r\n            case ',':\r\n              // ignore extra commas\r\n              break;\r\n            default:\r\n              stack.push(state);\r\n              state = VALUE;\r\n              --i;\r\n              break;\r\n          }\r\n          break;\r\n        case OBJECT:\r\n          switch (c) {\r\n            case ' ':\r\n            case '\\t':\r\n            case '\\n':\r\n            case '\\r':\r\n              // ignore whitespace\r\n              break;\r\n            case '}':\r\n              emit('closeobject');\r\n              state = stack.length ? stack.pop() : BEGIN;\r\n              break;\r\n            case '{':\r\n            case '[':\r\n            case ']':\r\n            case ',':\r\n              // ignore stray characters\r\n              break;\r\n            default:\r\n              stack.push(state);\r\n              state = KEY;\r\n              --i;\r\n              break;\r\n          }\r\n          break;\r\n        case KEY:\r\n          if (!parseKey()) {\r\n            // continue parsing when we get more data\r\n            return;\r\n          }\r\n          break;\r\n        default:\r\n          throw new Error('unexpected state ' + state);\r\n      }\r\n    }\r\n\r\n    buffer = buffer.substring(i);\r\n    i = 0;\r\n  }\r\n\r\n  function end() {\r\n    return parse(',');\r\n  }\r\n}\r\n"],"sourceRoot":""}